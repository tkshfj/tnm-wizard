# TNM Wizard PoC - Design Notes

* FastAPI backend (`app.py`)
* Jinja form template (`form_generic.html`)
* Front-end logic (`visibility.js`)
* CSS layout (nodal metastasis and histologic mix)
* Histologic type/subtype/percentage handling
* Error messages encountered and how they were resolved
* Commit messages used

All code snippets below are representative of the **current** design. Earlier broken or intermediate variants are described in the error sections.

---

## 1. Overall Goal

We are building a small intranet TNM Wizard web app that:

* Runs via FastAPI + Uvicorn (PoC on macOS, later on Windows intranet).
* Renders organ-specific forms based on YAML configuration (e.g. `lung.yaml`).
* Collects TNM, nodal metastasis, and histologic details via structured inputs.
* Generates a standardized diagnostic paragraph (Jinja2 template).
* Supports:

  * TNM → Stage lookup with wildcard patterns.
  * Nodal metastasis summary like `1R (1/3), 3p (2/4)`.
  * Histologic mix summary like
    `腺癌, 乳頭腺癌 (主 50%), 腺房腺癌 30%, 非浸潤性腺癌 粘液非産生 20%`.
  * Autofilling the description textarea from the histologic mix (so it can be edited manually).

---

## 2. Backend: `app.py`

### 2.1 Config Loading: `OrganConfig` and `FORM_CONFIGS`

We load YAML configs for each organ and keep them in memory:

```python
from pathlib import Path
import json
import yaml
import re
from typing import Mapping, List, Dict, Any
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

BASE_DIR = Path(__file__).resolve().parent
CONFIG_DIR = BASE_DIR / "config"

app = FastAPI(title="TNM Wizard")
templates = Jinja2Templates(directory=str(BASE_DIR / "templates"))

app.mount("/static", StaticFiles(directory=str(BASE_DIR / "static")), name="static")


class OrganConfig:
  def __init__(self, cfg: dict):
      self.organ = cfg["organ"]
      self.display_name = cfg.get("display_name", self.organ)
      self.version = cfg.get("version", "")
      self.sections = cfg["sections"]
      self.template_name = cfg["template"]

      # TNM stage table: can be dict or an external file
      self.stage_table = {}
      tnm = cfg.get("tnm_stage_table")
      if isinstance(tnm, dict):
          self.stage_table = tnm
      elif isinstance(tnm, str):
          path = CONFIG_DIR / tnm
          if path.suffix == ".json":
              self.stage_table = json.loads(path.read_text(encoding="utf-8"))
          elif path.suffix in (".yaml", ".yml"):
              self.stage_table = yaml.safe_load(path.read_text(encoding="utf-8"))


def load_all_configs():
  configs = {}
  for path in CONFIG_DIR.glob("*.yaml"):
      data = yaml.safe_load(path.read_text(encoding="utf-8"))
      oc = OrganConfig(data)
      configs[oc.organ] = oc
  return configs


FORM_CONFIGS = load_all_configs()
```

Key points:

* Each organ config includes:

  * `organ`, `display_name`, `version`.
  * `sections`: list of sections with fields (from YAML).
  * `template_name`: report template for that organ.
  * `tnm_stage_table`: either inline dict or separate JSON/YAML.

---

### 2.2 TNM Stage Lookup with Wildcards

We added support for entries like `"T*,N*,M1*": "Stage IV"`:

```python
def derive_stage(organ_cfg: OrganConfig, pT: str, pN: str, pM: str) -> str:
    """
    TNM -> stage lookup with simple wildcard support.
    - Exact match has priority (e.g. 'T1a,N0,M0')
    - If no exact match, try patterns with '*' such as 'T*,N*,M1*'
    """
    t = pT.replace("p", "")
    n = pN.replace("p", "")
    m = pM.replace("p", "")
    key = f"{t},{n},{m}"
    table = organ_cfg.stage_table

    # 1. Exact match
    if key in table:
        return table[key]

    # 2. Wildcard patterns
    for pattern, stage in table.items():
        if "*" not in pattern:
            continue
        regex_pattern = "^" + re.escape(pattern).replace("\\*", ".*") + "$"
        if re.match(regex_pattern, key):
            return stage

    # 3. Fallback
    return "Stage ?"
```

Example in `lung.yaml`:

```yaml
tnm_stage_table:
  "Tis,N0,M0": "Stage 0"
  "T1mi,N0,M0": "Stage IA1"
  "T1a,N0,M0": "Stage IA1"
  "T1b,N0,M0": "Stage IA2"
  "T1c,N0,M0": "Stage IA3"
  "T2a,N0,M0": "Stage IB"
  ...
  "T*,N*,M1*": "Stage IV"
```

---

### 2.3 Form Extraction: `extract_fields`

The form extraction respects `type` and `options` from the YAML:

```python
def extract_fields(form, organ_cfg: OrganConfig) -> dict:
    data = {}
    for section in organ_cfg.sections:
        for field in section["fields"]:
            name = field["name"]
            ftype = field.get("type")
            has_options = bool(field.get("options"))

            if ftype == "checkbox":
                if has_options:
                    # multi-select
                    value = form.getlist(name)
                else:
                    value = form.get(name) == "true"
            else:
                value = form.get(name)

            if ftype == "number" and value not in (None, "", []):
                try:
                    value = float(value)
                except ValueError:
                    value = None

            data[name] = value
    return data
```

---

### 2.4 Nodal Metastasis Summary: `build_nodal_summary`

For LN station inputs like:

* `LN1R_positive`, `LN1R_total`, `LN1R` (checkbox)
* `LN3p_positive`, `LN3p_total`, `LN3p`

we build a summary such as `1R (1/3), 3p (2/4)`:

```python
def build_nodal_summary(form_data: Mapping[str, str]) -> str:
    """
    Parse LNxx_positive / LNxx_total pairs from the form data and build a
    compact summary like: '1R (1/3), 3p (2/4)'.
    """
    summary_parts = []

    POS_SUFFIX = "_positive"
    TOTAL_SUFFIX = "_total"

    for key, pos_val in form_data.items():
        if not key.endswith(POS_SUFFIX):
            continue

        pos_val = (pos_val or "").strip()
        if pos_val == "":
            continue

        base = key[:-len(POS_SUFFIX)]  # "LN1R" from "LN1R_positive"
        total_key = f"{base}{TOTAL_SUFFIX}"
        total_val = (form_data.get(total_key) or "").strip()

        # Optional: keep only stations whose checkbox was checked
        checkbox_val = (form_data.get(base) or "").strip()
        if checkbox_val.lower() not in {"true", "on", "1"}:
            # Currently we allow inclusion if positive is entered.
            pass

        # Label: strip "LN" prefix → "1R", "3p" etc.
        label = base[2:] if base.startswith("LN") else base

        if total_val:
            summary_parts.append(f"{label} ({pos_val}/{total_val})")
        else:
            summary_parts.append(f"{label}({pos_val}/?)")

    return ", ".join(summary_parts)
```

---

### 2.5 Histologic Mix Summary (Backend)

Although the primary histologic summary is now handled client-side (into the textarea), we still had a backend function for histologic type/subtype/percent:

```python
def build_histologic_summary(form_data: Mapping[str, str], cfg) -> str:
    """
    Example of constructing a histologic summary like:
    '腺癌, 乳頭腺癌 (主 60%), 粘液産生腺癌 20%, 微小乳頭腺癌 20%'
    from histologic_type, primary subtype, and other subtypes with percentages.
    """
    histo_type_code = (form_data.get("histologic_type") or "").strip()
    primary_code = (form_data.get("histologic_primary_subtype") or "").strip()
    primary_pct = (form_data.get("histologic_primary_percent") or "").strip()

    type_label = ""
    primary_label = ""
    other_labels: Dict[str, str] = {}

    sections = getattr(cfg, "sections", None)
    if sections is None and isinstance(cfg, dict):
        sections = cfg.get("sections", [])

    for section in sections or []:
        if not isinstance(section, dict):
            continue
        for field in section.get("fields", []):
            if not isinstance(field, dict):
                continue
            name = field.get("name")

            if name == "histologic_type":
                for opt in field.get("options", []):
                    if opt.get("code") == histo_type_code:
                        type_label = opt.get("label") or ""

            if name == "histologic_primary_subtype":
                for opt in field.get("options", []):
                    if opt.get("code") == primary_code:
                        primary_label = opt.get("label") or ""

            if name == "histologic_other_subtypes":
                for opt in field.get("options", []):
                    code = opt.get("code")
                    label = opt.get("label")
                    if code and label:
                        other_labels[code] = label

    selected_others: List[str] = (
        form_data.getlist("histologic_other_subtypes")
        if hasattr(form_data, "getlist")
        else (form_data.get("histologic_other_subtypes") or "").split(",")
    )
    selected_others = [c.strip() for c in selected_others if c.strip()]

    other_parts: List[str] = []
    for code in selected_others:
        label = other_labels.get(code, code)
        pct_key = f"histologic_other_subtypes_{code}_pct"
        pct_val = (form_data.get(pct_key) or "").strip()
        if pct_val:
            other_parts.append(f"{label} {pct_val}%")
        else:
            other_parts.append(label)

    parts: List[str] = []
    if type_label:
        parts.append(type_label)
    if primary_label:
        if primary_pct:
            parts.append(f"{primary_label} (主 {primary_pct}%)")
        else:
            parts.append(primary_label)
    if other_parts:
        parts.extend(other_parts)

    return ", ".join(parts)
```

Later, we moved to a **histologic mix table** approach (multiple type/subtype/percent rows), and the corresponding summary is now generated on the client side and inserted into the description.

---

### 2.6 Main Routes

Index and organ-specific form:

```python
@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    organs = [
        {"code": k, "label": cfg.display_name}
        for k, cfg in FORM_CONFIGS.items()
    ]
    return templates.TemplateResponse(
        "index.html",
        {"request": request, "organs": organs},
    )


@app.get("/{organ}", response_class=HTMLResponse)
async def show_form(request: Request, organ: str):
    cfg = FORM_CONFIGS.get(organ)
    if not cfg:
        return HTMLResponse("Unknown organ", status_code=404)

    return templates.TemplateResponse(
        "form_generic.html",
        {"request": request, "config": cfg},
    )
```

Report generation:

```python
@app.post("/{organ}/generate", response_class=HTMLResponse)
async def generate_report(request: Request, organ: str):
    cfg = FORM_CONFIGS.get(organ)
    if cfg is None:
        return HTMLResponse("Unknown organ", status_code=404)

    form = await request.form()
    form_dict: Dict[str, Any] = dict(form)

    data = extract_fields(form, cfg)

    version = getattr(cfg, "version", None)
    if version is None and isinstance(cfg, dict):
        version = cfg.get("version")
    if version is not None:
        data["version"] = version

    sections = getattr(cfg, "sections", None)
    if sections is None and isinstance(cfg, dict):
        sections = cfg.get("sections", [])

    # histologic_summary is still computed but may not be used directly
    data["histologic_summary"] = build_histologic_summary(form, cfg)

    has_nodal_stations = any(
        isinstance(field, dict) and field.get("type") == "nodal_stations"
        for section in (sections or [])
        if isinstance(section, dict)
        for field in section.get("fields", [])
    )
    if has_nodal_stations:
        data["nodal_summary"] = build_nodal_summary(form_dict)
    else:
        data["nodal_summary"] = ""

    pT = data.get("pT")
    pN = data.get("pN")
    pM = data.get("pM")
    if pT and pN and pM:
        data["stage"] = derive_stage(cfg, pT, pN, pM)

    template = templates.get_template(
        getattr(cfg, "template_name", None)
        if not isinstance(cfg, dict)
        else cfg.get("template_name")
    )
    report_text = template.render(data=data)

    return templates.TemplateResponse(
        "result.html",
        {
            "request": request,
            "report_text": report_text,
            "organ": organ,
        },
    )
```

---

## 3. Jinja Template: `form_generic.html`

### 3.1 Input Rendering Macro

The `render_input` macro handles all generic field types, including histologic subtype filtering and textarea:

```html
{% macro render_input(field) %}
  {% if field.type == "radio" %}
    {% set default_value = field.default or "" %}
    {% for opt in field.options %}
      <label
        {% if opt.help %} title="{{ opt.help }}"{% endif %}
        class="radio-option"
      >
        <input
          type="radio"
          name="{{ field.name }}"
          value="{{ opt.code }}"
          {% if opt.code == default_value or opt.default %}checked{% endif %}
          required
        >
        {{ opt.label }}
      </label>
    {% endfor %}

  {% elif field.type == "select" %}
    <select
      name="{{ field.name }}"
      {% if field.depends_on_histologic_type %}
        data-histologic-subtype="true"
      {% endif %}
    >
      {% for opt in field.options %}
        <option
          value="{{ opt.code }}"
          {% if opt.parent_type %}
            data-parent-type="{{ opt.parent_type }}"
          {% endif %}
        >
          {{ opt.label }}
        </option>
      {% endfor %}
    </select>

  {% elif field.type == "checkbox" %}
    {% if field.options %}
      {% if field.with_percent %}
        {# subtype with percentages, old pattern #}
        ...
      {% else %}
        {% for opt in field.options %}
          <label class="checkbox-option"
                 {% if opt.help %}title="{{ opt.help }}"{% endif %}
                 {% if field.depends_on_histologic_type and opt.parent_type %}
                   data-histologic-subtype-checkbox="true"
                   data-parent-type="{{ opt.parent_type }}"
                 {% endif %}
          >
            <input type="checkbox" name="{{ field.name }}" value="{{ opt.code }}">
            {{ opt.label }}
          </label>
        {% endfor %}
      {% endif %}
    {% else %}
      <label class="checkbox-option">
        <input type="checkbox" name="{{ field.name }}" value="true">
        {{ field.label }}
      </label>
    {% endif %}

  {% elif field.type == "number" %}
    <input
      type="number"
      min="0"
      step="{{ field.step or 1 }}"
      name="{{ field.name }}"
      {% if field.input_width %}
        style="width: {{ field.input_width }};"
      {% endif %}
    >

  {% elif field.type == "free_text" %}
    <input
      type="text"
      name="{{ field.name }}"
      {% if field.input_width %}
        style="width: {{ field.input_width }};"
      {% endif %}
    >

  {% elif field.type == "textarea" %}
    <textarea
      name="{{ field.name }}"
      rows="{{ field.rows or 2 }}"
      class="{{ field.css_class or '' }}"
      id="{{ field.name }}"
    ></textarea>

  {% else %}
    <input type="text" name="{{ field.name }}">
  {% endif %}
{% endmacro %}
```

Key points:

* `textarea` now gets `id="{{ field.name }}"`, so the JS helper can find `#description`.
* For textarea `description`, we later wrap its label with a button.

---

### 3.2 Section Rendering: Histologic Mix and Nodal Stations

We introduced a special `histologic_mix` field type that renders a table:

```html
{% macro render_section_fields(section) %}
  {% for field in section.fields %}

    {% if field.type == "histologic_mix" %}
      <div class="field histologic-mix">
        <label>{{ field.label }}:</label>

        <table class="histologic-mix-table">
          <thead>
            <tr>
              <th>組織型</th>
              <th>組織亜型</th>
              <th>割合(%)</th>
            </tr>
          </thead>
          <tbody>
            {% set max_rows = field.rows or 4 %}
            {% for i in range(1, max_rows + 1) %}
              <tr class="histologic-mix-row" data-row-index="{{ i }}">
                <td>
                  <select
                    name="histologic_type_{{ i }}"
                    class="histologic-type-select"
                    data-row="{{ i }}"
                  >
                    <option value="">--</option>
                    {% for t in field.types %}
                      <option value="{{ t.code }}">{{ t.label }}</option>
                    {% endfor %}
                  </select>
                </td>

                <td>
                  <select
                    name="histologic_subtype_{{ i }}"
                    class="histologic-subtype-select"
                    data-row="{{ i }}"
                  >
                    <option value="">--</option>
                    {% for t in field.types %}
                      {% for st in t.subtypes %}
                        <option
                          value="{{ st.code }}"
                          data-parent-type="{{ t.code }}"
                        >
                          {{ st.label }}
                        </option>
                      {% endfor %}
                    {% endfor %}
                  </select>
                </td>

                <td style="text-align: right;">
                  <input
                    type="number"
                    name="histologic_percent_{{ i }}"
                    class="histologic-percent-input"
                    min="0"
                    max="100"
                    step="1"
                    style="width: 3rem; text-align: right;"
                  >
                </td>
              </tr>
            {% endfor %}
          </tbody>
        </table>

        <small class="histologic-hint">
          合計が 100% になるように入力します。主たる組織亜型は最大割合の組み合わせから自動判定されます。
        </small>
      </div>
```

Nodal stations:

```html
    {% elif field.type == "nodal_stations" %}
      <div class="field nodal-stations">
        <label>{{ field.label }}:</label>

        {% for st in field.stations %}
          {% set chk_name      = "LN" ~ st.code %}
          {% set positive_name = "LN" ~ st.code ~ "_positive" %}
          {% set total_name    = "LN" ~ st.code ~ "_total" %}

          <div class="nodal-row">
            <label class="station-cell">
              <input type="checkbox" name="{{ chk_name }}" value="true">
              <span class="station-code">{{ st.label }}</span>
            </label>

            <input
              type="number"
              name="{{ positive_name }}"
              class="nodal-input"
              min="0"
              step="1"
              style="width: 3.0rem;"
              placeholder="+"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >

            <span
              class="nodal-slash"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >/</span>

            <input
              type="number"
              name="{{ total_name }}"
              class="nodal-input"
              min="0"
              step="1"
              style="width: 3.0rem;"
              placeholder="#"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >
          </div>
        {% endfor %}
      </div>

    {% else %}
      <div class="field"
           data-field-name="{{ field.name }}"
           {% if field.visible_if %}
             data-visible-if-field="{{ field.visible_if['field'] }}"
             data-visible-if-values="{{ field.visible_if['values'] | join(',') }}"
           {% endif %}
      >
        {% if not (field.type == "checkbox" and not field.options) %}
          {% if field.name == "description" %}
            <div style="display:flex; align-items:flex-start; gap:0.5rem;">
              <label for="{{ field.name }}">{{ field.label }}:</label>
              <button
                type="button"
                id="btn-fill-description-from-histology"
                style="font-size:0.8rem; padding:0.2rem 0.5rem;"
              >
                組織型から自動入力
              </button>
            </div>
          {% else %}
            <label>{{ field.label }}:</label>
          {% endif %}
        {% endif %}
        {{ render_input(field) }}
      </div>
    {% endif %}
  {% endfor %}
{% endmacro %}
```

### 3.3 Collapsible Sections (Nodal Metastasis)

We used `<details>` / `<summary>` to make the nodal section collapsible:

```html
<form method="post" action="/{{ config.organ }}/generate">
  {% for section in config.sections %}

    {% if section.id == "nodal_metastasis" %}
      <details class="section-collapsible" open>
        <summary>{{ section.title }}</summary>
        <fieldset>
          <legend style="display:none">{{ section.title }}</legend>
          {{ render_section_fields(section) }}
        </fieldset>
      </details>

    {% else %}
      <fieldset>
        <legend>{{ section.title }}</legend>
        {{ render_section_fields(section) }}
      </fieldset>
    {% endif %}

  {% endfor %}

  <button type="submit">診断文を生成</button>
</form>
```

---

## 4. JavaScript: `static/visibility.js`

### 4.1 Generic Conditional Visibility

We generalized show/hide logic with `data-visible-if-field` and `data-visible-if-values`:

```js
document.addEventListener("DOMContentLoaded", () => {
  // 1) Generic visible_if
  const conditionalFields = document.querySelectorAll("[data-visible-if-field]");

  function getFieldValue(name) {
    const elements = document.querySelectorAll(`[name="${name}"]`);
    if (!elements.length) return "";

    const el = elements[0];

    if (el.tagName === "SELECT") {
      return el.value;
    }
    if (el.type === "radio") {
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      return checked ? checked.value : "";
    }
    if (el.type === "checkbox") {
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      return checked ? "true" : "false";
    }
    return el.value || "";
  }

  function updateVisibility() {
    conditionalFields.forEach((el) => {
      const depField = el.dataset.visibleIfField;
      const allowed = (el.dataset.visibleIfValues || "")
        .split(",")
        .map((v) => v.trim())
        .filter((v) => v !== "");
      const current = getFieldValue(depField);

      if (allowed.includes(current)) {
        if (el.classList.contains("nodal-extra")) {
          el.style.display = "inline-flex";
        } else {
          el.style.display = "";
        }
      } else {
        el.style.display = "none";
      }
    });
  }

  updateVisibility();

  document.addEventListener("change", (event) => {
    const name = event.target.name;
    if ([...conditionalFields].some((f) => f.dataset.visibleIfField === name)) {
      updateVisibility();
    }
  });
```

This is used for:

* Nodal numeric inputs: `data-visible-if-field="LN1R"` and `data-visible-if-values="true"`.
* Any other conditional fields in YAML using `visible_if`.

### 4.2 Histologic Type/Subtype Filtering in Mix Table

Per-row type → subtype filtering:

```js
  // Histologic mix rows: type -> subtype filtering per row
  const mixRows = document.querySelectorAll(".histologic-mix-row");

  mixRows.forEach((row) => {
    const typeSelect = row.querySelector(".histologic-type-select");
    const subtypeSelect = row.querySelector(".histologic-subtype-select");
    if (!typeSelect || !subtypeSelect) return;

    const allOptions = Array.from(subtypeSelect.options).slice(1); // skip "--"

    function updateSubtypes() {
      const currentType = typeSelect.value;
      const currentValue = subtypeSelect.value;

      subtypeSelect.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "--";
      subtypeSelect.appendChild(placeholder);

      const candidates = allOptions.filter((opt) => {
        const parent = opt.dataset.parentType || "";
        return !currentType || parent === currentType;
      });

      candidates.forEach((opt) => {
        subtypeSelect.appendChild(opt.cloneNode(true));
      });

      if (
        currentValue &&
        Array.from(subtypeSelect.options).some((o) => o.value === currentValue)
      ) {
        subtypeSelect.value = currentValue;
      }
    }

    updateSubtypes();
    typeSelect.addEventListener("change", updateSubtypes);
  });
```

### 4.3 Sum of Percentages and Warning

We added a hint that checks if the total percentage is ~100:

```js
  function updateHistologicTotal() {
    const inputs = document.querySelectorAll(".histologic-percent-input");
    let total = 0;
    inputs.forEach((input) => {
      const v = parseFloat(input.value);
      if (!isNaN(v)) total += v;
    });

    const hint = document.querySelector(".histologic-hint");
    if (!hint) return;

    if (total === 0) {
      hint.textContent = "合計が 100% になるように入力します。主たる組織亜型は最大割合から自動判定されます。";
      hint.style.color = "";
    } else if (Math.abs(total - 100) < 0.5) {
      hint.textContent = `現在の合計: 約 ${total.toFixed(1)}%`;
      hint.style.color = "";
    } else {
      hint.textContent = `現在の合計: 約 ${total.toFixed(1)}%（100% になるように調整してください）`;
      hint.style.color = "red";
    }
  }

  document.addEventListener("input", (ev) => {
    if (ev.target.classList && ev.target.classList.contains("histologic-percent-input")) {
      updateHistologicTotal();
    }
  });

  updateHistologicTotal();
```

### 4.4 Histologic Mix → Description Textarea

We added a helper that builds:

`腺癌, 乳頭腺癌 (主 50%), 腺房腺癌 30%, 非浸潤性腺癌 粘液非産生 20%`

and writes it into `textarea#description` when the button is pressed:

```js
  function buildHistologicSummaryFromDOM() {
    const rows = Array.from(document.querySelectorAll(".histologic-mix-row"));
    const rowData = [];

    rows.forEach((row) => {
      const typeSel = row.querySelector(".histologic-type-select");
      const subtypeSel = row.querySelector(".histologic-subtype-select");
      const pctInput = row.querySelector(".histologic-percent-input");

      if (!typeSel || !subtypeSel || !pctInput) return;

      const pctStr = (pctInput.value || "").trim();
      const typeCode = (typeSel.value || "").trim();
      const subtypeCode = (subtypeSel.value || "").trim();

      if (!typeCode && !subtypeCode && !pctStr) return;

      const pct = parseFloat(pctStr);
      const pctVal = isNaN(pct) ? 0 : pct;

      const typeLabel =
        (typeSel.options[typeSel.selectedIndex] &&
          typeSel.options[typeSel.selectedIndex].textContent.trim()) ||
        "";

      const subtypeLabel =
        (subtypeSel.options[subtypeSel.selectedIndex] &&
          subtypeSel.options[subtypeSel.selectedIndex].textContent.trim()) ||
        "";

      rowData.push({
        typeCode,
        subtypeCode,
        pct: pctVal,
        typeLabel,
        subtypeLabel,
      });
    });

    if (!rowData.length) return "";

    // primary = highest pct
    let primary = rowData[0];
    rowData.forEach((r) => {
      if (r.pct > primary.pct) {
        primary = r;
      }
    });

    const parts = [];

    if (primary.typeLabel) parts.push(primary.typeLabel);
    if (primary.subtypeLabel) {
      parts.push(`${primary.subtypeLabel} (主 ${primary.pct.toFixed(0)}%)`);
    } else if (primary.pct > 0) {
      parts.push(`(主 ${primary.pct.toFixed(0)}%)`);
    }

    rowData.forEach((r) => {
      if (r === primary || !r.pct) return;

      const tLabel = r.typeLabel;
      const sLabel = r.subtypeLabel;
      const pctText = `${r.pct.toFixed(0)}%`;

      if (r.typeCode === primary.typeCode && primary.typeLabel) {
        if (sLabel) {
          parts.push(`${sLabel} ${pctText}`);
        } else {
          parts.push(pctText);
        }
      } else {
        if (tLabel && sLabel) {
          parts.push(`${tLabel} ${sLabel} ${pctText}`);
        } else if (tLabel) {
          parts.push(`${tLabel} ${pctText}`);
        } else if (sLabel) {
          parts.push(`${sLabel} ${pctText}`);
        }
      }
    });

    return parts.join(", ");
  }

  const btn = document.getElementById("btn-fill-description-from-histology");
  if (btn) {
    btn.addEventListener("click", () => {
      const textarea = document.querySelector("textarea#description");
      if (!textarea) return;

      const summary = buildHistologicSummaryFromDOM();
      if (!summary) return;

      textarea.value = summary;
      textarea.focus();
    });
  }
});
```

Important detail: originally the button did nothing because either:

* There was no `id="description"` on the textarea, or
* There was a nested `DOMContentLoaded` inside another `DOMContentLoaded`, which never executed.

We refactored to a **single** top-level `DOMContentLoaded` and ensured `id="description"` was added in the Jinja template.

---

## 5. CSS: `static/style.css`

Relevant parts, focusing on nodal stations and numeric alignment:

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  margin: 1.5rem;
}

fieldset {
  margin-bottom: 1rem;
  padding: 1rem;
}

.field {
  margin-bottom: 0.5rem;
}

/* Nodal station layout */
.nodal-stations {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  align-items: flex-end; /* align rows to the right if desired */
}

.nodal-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

/* Station column (checkbox + code) */
.station-cell {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  width: 3.5rem; /* enough for 10R etc. */
}

/* "1R", "4R" etc. right-aligned */
.station-code {
  min-width: 2.0rem;
  text-align: right;
  font-feature-settings: "tnum";
}

/* Hide positive/total until JS shows them */
.nodal-extra {
  display: none;
  align-items: center;
  gap: 0.25rem;
}

.nodal-input {
  width: 3ch;
  text-align: right;  /* numeric content right-aligned */
}

.nodal-slash {
  text-align: center;
}

/* Histologic table (optional extra styling) */
.histologic-mix-table {
  border-collapse: collapse;
  margin-top: 0.5rem;
}

.histologic-mix-table th,
.histologic-mix-table td {
  padding: 0.25rem 0.5rem;
}
```

We discussed optionally customizing `<summary>` markers:

```css
/* Remove default triangle if a custom marker is desired */
/* summary::-webkit-details-marker { display: none; } */
```

This hides the default disclosure triangle on WebKit (Safari/Chrome); Firefox uses a different pseudo-element, so cross-browser support needs more rules if a custom icon is desired.

---

## 6. Configuration Example: Histologic Mix in `lung.yaml`

A typical `histologic_mix` field in YAML:

```yaml
- id: histology
  title: "組織型"
  fields:
    - name: histologic_mix
      label: "組織型・亜型・割合"
      type: histologic_mix
      rows: 4
      types:
        - code: "腺癌"
          label: "腺癌"
          subtypes:
            - { code: "乳頭腺癌", label: "乳頭腺癌" }
            - { code: "腺房腺癌", label: "腺房腺癌" }
            - { code: "粘液産生腺癌", label: "粘液産生腺癌" }
            - { code: "微小乳頭腺癌", label: "微小乳頭腺癌" }
        - code: "非浸潤性腺癌"
          label: "非浸潤性腺癌"
          subtypes:
            - { code: "粘液非産生", label: "粘液非産生" }
            - { code: "粘液産生", label: "粘液産生" }
        - code: "扁平上皮癌"
          label: "扁平上皮癌"
          subtypes:
            - { code: "角化型", label: "角化型" }
            - { code: "非角化型", label: "非角化型" }
```

This structure is consumed by the `histologic_mix` renderer and the JS filtering.

---

## 7. Error Messages Encountered and Fixes

### 7.1 Missing `python-multipart`

Error:

```text
AssertionError: The `python-multipart` library must be installed to use form parsing.
```

Cause: FastAPI needs `python-multipart` for `await request.form()`.

Fix:

```bash
pip install python-multipart
```

### 7.2 Jinja `%` Format Error

Error:

```text
ValueError: incomplete format
  File "lung_report.j2", line 4
    腫瘍径 {{ "%"|format(data.tumor_size or 0) }} mm
```

Cause: Misuse of `"%".format(...)`.

Fix: Use correct format pattern, e.g.:

```jinja2
腫瘍径 {{ "%.0f"|format(data.tumor_size or 0) }} mm
```

or simply:

```jinja2
腫瘍径 {{ data.tumor_size or 0 }} mm
```

### 7.3 Unknown Tag `comment`

Error:

```text
TemplateSyntaxError: Encountered unknown tag 'comment'. Jinja was looking for 'elif' or 'else' or 'endif'.
```

Cause: Used `{% comment %}` (Django style) instead of Jinja’s `{# ... #}`.

Fix: Replace with:

```jinja2
{# comment text #}
```

### 7.4 `TypeError: 'builtin_function_or_method' object is not iterable`

Error:

```text
TypeError: 'builtin_function_or_method' object is not iterable
  File "form_generic.html", line 21
    data-visible-if-values="{{ field.visible_if.values | join(',') }}"
```

Cause: `field.visible_if.values` was referencing the **method** `values`, not the list. The correct access is `field.visible_if['values']`.

Fix:

```jinja2
data-visible-if-values="{{ field.visible_if['values'] | join(',') }}"
```

### 7.5 `AttributeError: 'dict' object has no attribute 'fields'`

Error:

```text
AttributeError: 'dict' object has no attribute 'fields'
  if any(f.type == "nodal_stations" for section in cfg.sections for f in section.fields):
```

Cause: `cfg.sections` entries are dicts, not objects with `.fields`.

Fix:

```python
has_nodal_stations = any(
    isinstance(field, dict) and field.get("type") == "nodal_stations"
    for section in (sections or [])
    if isinstance(section, dict)
    for field in section.get("fields", [])
)
```

### 7.6 Jinja `else` Nesting Error

Error:

```text
TemplateSyntaxError: Encountered unknown tag 'else'. You probably made a nesting mistake.
```

Cause: Unbalanced `{% if %}` / `{% endif %}` when wrapping the description label with the helper button.

Fix: Ensure that:

```jinja2
{% if field.name == "description" %}
  ... 
{% else %}
  ...
{% endif %}
```

matches exactly, with no stray `{% else %}`.

### 7.7 Histologic Mix Button Not Working

Symptom: After clicking the “組織型から自動入力” button, the description textarea remained empty.

Causes:

1. The textarea had no `id="description"`, but JS looked for `textarea#description`.
2. There was a nested `DOMContentLoaded` inside another `DOMContentLoaded`, so the handler might not run.

Fixes:

* Add `id="{{ field.name }}"` for the description textarea.
* Use a single top-level `DOMContentLoaded` and attach the button handler there.

---

## 8. Commit Messages Used

We iterated over several commits; examples include:

* `feat(tnm-wizard): add lung TNM proof-of-concept web app with clipboard support`
* `feat(tnm-wizard): enhance lung cancer report template`
* `feat(tnm-wizard): add collapsible nodal metastasis input`
* `feat(tnm-wizard): add nodal metastasis input and make it collapsible`
* `feat(tnm-wizard): add histologic type/subtype/percentage table and description autofill`

The final suggested message for the histologic mix plus description autofill was:

```text
feat(tnm-wizard): add histologic type/subtype/percentage table and description autofill
```

---

## 9. Summary

In this PoC, we have:

* Built a **config-driven TNM Wizard** using FastAPI + Jinja + YAML.
* Implemented **TNM → Stage** mapping with **wildcard support**.
* Designed a flexible `form_generic.html` template with:

  * Special handling for `nodal_stations` (checkbox + positive/total, conditional display).
  * A **histologic mix table** with type/subtype/percentage rows.
  * A description textarea with a button to auto-fill from histologic mix.
* Implemented `visibility.js` to:

  * Handle generic `visible_if` dependencies.
  * Filter subtypes by histologic type in each row.
  * Keep track of histologic percentage totals.
  * Generate a histologic summary and push it into the description textarea.
* Styled nodal metastasis and histologic sections via CSS for alignment, compact numeric inputs, and collapsible sections.
* Debugged multiple FastAPI/Jinja issues, including missing `python-multipart`, format errors, Jinja comment syntax, nested conditionals, and dict vs object access.

This provides a reusable foundation for expanding to other organs (breast, colorectal, stomach, esophagus, etc.) by adding new YAML configs and templates while reusing the same backend and frontend infrastructure.
