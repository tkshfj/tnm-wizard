# Code Review: TNM Staging Wizard for Raspberry Pi Deployment
Date: 2026-01-13
We’ve read through the current codebase (app.py, templates, static JS/CSS, and lung.yaml). Here’s a focused review tied to how it will behave in production on the Pi.

---

## 1. Project structure

From the zip:

* `app.py` – FastAPI app, config loading, staging, report generation.
* `templates/`

  * `index.html` – organ picker.
  * `form_generic.html` – main wizard form (including histologic mix table + description button).
  * `result.html` – generated report display.
  * `lung_report.j2` – Jinja2 text template for lung report.
* `static/`

  * `style.css` – layout / form styling.
  * `visibility.js` – all dynamic behaviour (visible_if, histologic mix, description autofill).
* `config/`

  * `lung.yaml` – organ definition (sections, fields, histologic_mix, TNM table, template etc.).
* `requirements.txt` – `fastapi`, `uvicorn`, `jinja2`, `pyyaml`, `python-multipart`.

This layout is very friendly for a simple uvicorn+systemd deployment on a Pi: everything is file-relative from `app.py`.

---

## 2. Backend (app.py)

### 2.1 Config loading

```python
BASE_DIR = Path(__file__).resolve().parent
TEMPLATES_DIR = BASE_DIR / "templates"
STATIC_DIR = BASE_DIR / "static"
CONFIG_DIR = BASE_DIR / "config"
REPORTS_DIR = BASE_DIR / "reports"
```

* This means on the Pi we can just clone/unzip into `/opt/tnm-wizard` and run from there; no path hacking needed.
* `load_all_configs()` reads every `*.yaml` in `config/` into an `OrganConfig` dataclass and builds `FORM_CONFIGS` keyed by `organ`.

The lung YAML we saw matches the expected structure (organ, display_name, sections, tnm_stage_table, template).

### 2.2 FastAPI setup & static/templates

```python
app = FastAPI(title="TNM Wizard")
templates = Jinja2Templates(directory=str(TEMPLATES_DIR))
app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")
```

* Good: static is mounted under `/static`, which is what the HTML references.
* No CORS or extra middleware – fine for intranet-only use.

### 2.3 Routes

**Index**

```python
@app.get("/", response_class=HTMLResponse)
async def index(request: Request):
    organ_options = [
        {"code": cfg.organ, "label": cfg.display_name}
        for cfg in FORM_CONFIGS.values()
    ]
    return templates.TemplateResponse(
        "index.html", {"request": request, "organ_options": organ_options}
    )
```

* Clean: the template receives `{code, label}` for each organ.

**Form**

```python
@app.get("/{organ}/form", response_class=HTMLResponse)
async def show_form(request: Request, organ: str):
    cfg = FORM_CONFIGS.get(organ)
    if not cfg:
        raise HTTPException(status_code=404, detail="Unknown organ")
    return templates.TemplateResponse(
        "form_generic.html", {"request": request, "config": cfg}
    )
```

* `config` is the `OrganConfig` for that organ, used by `form_generic.html` to render sections and fields.

**Generate**

Key parts:

```python
@app.post("/{organ}/generate", response_class=HTMLResponse)
async def generate_report(request: Request, organ: str):
    cfg = FORM_CONFIGS.get(organ)
    if not cfg:
        raise HTTPException(status_code=404, detail="Unknown organ")

    form = await request.form()
    form_dict = dict(form)

    data = extract_fields(form, cfg)
    data["version"] = cfg.version
    data["organ"] = cfg.organ
    data["display_name"] = cfg.display_name

    data["histologic_summary"] = build_histologic_summary(form, cfg)
    data["histologic_description"] = (form_dict.get("description") or "").strip()

    t_stage = derive_t_stage(data)
    n_stage = derive_n_stage(data)
    m_stage = derive_m_stage(data)
    clinical_stage = derive_overall_stage(
        cfg, t_stage=t_stage, n_stage=n_stage, m_stage=m_stage, p_prefix=data.get("p_prefix")
    )
    data["t_stage"] = t_stage or ""
    data["n_stage"] = n_stage or ""
    data["m_stage"] = m_stage or ""
    data["clinical_stage"] = clinical_stage or ""
    data["stage_line"] = build_stage_line(t_stage, n_stage, m_stage, clinical_stage)

    report_text = render_report_text(cfg, data)

    return templates.TemplateResponse(
        "result.html",
        {
            "request": request,
            "config": cfg,
            "data": data,
            "report_text": report_text,
        },
    )
```

Observations:

* `extract_fields()` only pulls fields explicitly defined in YAML. `histologic_mix` fields are *layout only* – they don’t populate a backend value, which is exactly what we want given that the description is now driven by the textarea.
* `histologic_description` is bound directly to the `description` textarea in the HTML, which is what the new JS helper fills.
* `build_histologic_summary()` is still in place for legacy configs; lung can ignore it if the text template doesn’t use `histologic_summary` (or uses it as optional).

**Staging functions**

* `derive_t_stage`, `derive_n_stage`, `derive_m_stage` pull from `data["T"]`, `data["N"]`, `data["M"]` etc.
* `derive_overall_stage` walks `cfg.tnm_stage_table` and picks the first matching row. Lung YAML’s table layout matches this logic (columns for T, N, M, p_prefix, stage).

This is all deterministic and safe for intranet use – no external calls.

**Entrypoint**

```python
if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)
```

* For Pi deployment via systemd we’ll *not* use this block; instead we’ll call uvicorn directly from systemd (see below).

---

## 3. Frontend: form_generic.html

Key pieces relevant to histologic logic and deployment:

### 3.1 Histologic mix table

The special block in `render_section_fields`:

```jinja2
{% if field.type == "histologic_mix" %}
  <div class="field histologic-mix" id="histologic-mix">
    <label>{{ field.label }}:</label>

    <table class="histologic-mix-table">
      <thead>
        <tr>
          <th>組織型</th>
          <th>組織亜型</th>
          <th class="histologic-percent-header">割合(%)</th>
        </tr>
      </thead>
      <tbody>
        {% set max_rows = field.rows or 4 %}
        {% for i in range(1, max_rows + 1) %}
          <tr class="histologic-mix-row" data-row-index="{{ i }}">
            <td>
              <select
                name="histologic_type_{{ i }}"
                class="histologic-type-select"
                data-row="{{ i }}"
              >
                <option value="">--</option>
                {% for t in field.types %}
                  <option value="{{ t.code }}">{{ t.label }}</option>
                {% endfor %}
              </select>
            </td>

            <td>
              <select
                name="histologic_subtype_{{ i }}"
                class="histologic-subtype-select"
                data-row="{{ i }}"
              >
                <option value="">--</option>
                {% for t in field.types %}
                  {% for st in t.subtypes %}
                    <option
                      value="{{ st.code }}"
                      data-parent-type="{{ t.code }}"
                    >
                      {{ st.label }}
                    </option>
                  {% endfor %}
                {% endfor %}
              </select>
            </td>

            <td style="text-align: right;">
              <input
                type="number"
                name="histologic_percent_{{ i }}"
                class="histologic-percent-input"
                min="0"
                max="100"
                step="1"
                style="width: 3rem; text-align: right;"
              >
            </td>
          </tr>
        {% endfor %}
      </tbody>
    </table>

    <small class="histologic-hint">
      合計が 100% になるように入力します（AD のみ）。主たる組織亜型は最大割合から自動判定されます。
    </small>
  </div>
{% endif %}
```

* The header cell has `class="histologic-percent-header"` so the JS can hide it when there is no AD.
* The hint text is a single `.histologic-hint` element, also controlled from JS.

### 3.2 Description textarea and button

```jinja2
{% if field.name == "description" %}
  <div style="display:flex; align-items:center; gap:0.5rem;">
    <label for="{{ field.name }}">{{ field.label }}:</label>
    <button
      type="button"
      id="btn-fill-description-from-histology"
      style="font-size:0.8rem; padding:0.2rem 0.5rem;"
    >
      組織型から自動入力
    </button>
  </div>
{% else %}
  <label for="{{ field.name }}">{{ field.label }}:</label>
{% endif %}
{{ render_input(field) }}
```

And in the macro:

```jinja2
{% elif field.type == "textarea" %}
  <textarea
    name="{{ field.name }}"
    id="{{ field.name }}"
    rows="{{ field.rows or 2 }}"
    class="{{ field.css_class or '' }}"
  ></textarea>
{% endif %}
```

* `description` ⇒ `<textarea name="description" id="description">` which matches:

  * backend: `form_dict.get("description")`
  * JS: `document.querySelector("textarea#description")`.

So the new histologic helper is correctly wired.

---

## 4. Frontend: static/visibility.js (histology-specific parts)

### 4.1 AD vs non-AD behaviour

We saw:

* `const AD_CODE = "AD";` – must match `code: AD` in `lung.yaml` (adenocarcinoma). That’s the case now.

* For each `.histologic-mix-row`:

  * `updateRowSubtypes(row)` filters subtype options to those where `data-parent-type` matches the selected type.
  * `updateRowMode(row)`:

    * `type == AD` → percentage enabled + required + visible.
    * `type == ""` → percentage enabled but not required, visible.
    * `type != AD` → percentage cleared, disabled, and hidden via `style.visibility = "hidden"`.

* `enforceNonADSingleRowRule()` ensures:

  * If any non-AD type is selected in any row, that first non-AD row stays visible, all other rows are cleared and hidden (full non-AD pattern).

### 4.2 AD-only hint and header

`updateHistologicTotal()`:

* Sums `histologic-percent-input` values **only for enabled inputs** (i.e., AD rows).
* Tracks `hasAD`:

  * If `!hasAD`:

    * `header.style.display = "none"` (hides 割合(%)).
    * `hint.style.display = "none"; hint.textContent = ""` (no line about percentages).
  * If `hasAD`:

    * `header.style.display = ""`.
    * `hint.style.display = ""` and the message is:

      * full guidance when total=0,
      * current percent when ~100%,
      * red warning if off 100%.

This matches the goal: when we pick only a non-AD type (e.g. Minimally invasive adenocarcinoma), there is no AD row, so:

* Percent column and hint disappear.
* Only type + subtype remain, and description is generated without percentages.

### 4.3 Description summary generation

`buildHistologicSummaryFromDOM()`:

* Builds `rowData` from each `.histologic-mix-row`:

  * `typeCode`, `typeLabel`, `subtypeCode`, `subtypeLabel`, `pct`.

* Splits into:

  ```js
  const adRows    = rowData.filter((r) => r.typeCode === AD_CODE && r.pct > 0);
  const nonAdRows = rowData.filter((r) => r.typeCode && r.typeCode !== AD_CODE);
  ```

* AD case: `typeLabel, subtypeLabel (主 xx%), other subtypeLabel xx%` → e.g.:

  > Invasive adenocarcinoma, papillary (50%), acinar (30%), lepidic (20%)

* Non-AD case: *no percentages*, and only subtype in the final string:

  ```js
  nonAdRows.forEach((r) => {
    if (r.typeLabel && r.subtypeLabel) {
      parts.push(`${r.typeLabel} ${r.subtypeLabel}`);
    } else if (r.typeLabel) {
      parts.push(r.typeLabel);
    } else if (r.subtypeLabel) {
      parts.push(r.subtypeLabel);
    }
  });
  ```

Given a single non-AD row:

* type: “Minimally invasive adenocarcinoma”
* subtype: “Minimally invasive adenocarcinoma, nonmucinous”

The final `parts.join(", ")` becomes:

> Minimally invasive adenocarcinoma Minimally invasive adenocarcinoma, nonmucinous

If we want only the subtype for non-AD (as in your example), we will refine this later; for now this is how the code behaves.

`descButton` logic is correct: on click, it overwrites the textarea with this summary.

---

## 5. Deployment implications for Raspberry Pi 4

Given this codebase, deployment is straightforward; we do not need to change code for the Pi – we just run uvicorn against `app:app` under systemd.

Concretely (tying back to the earlier deployment plan):

1. On the Pi:

   ```bash
   sudo apt update
   sudo apt full-upgrade -y
   sudo apt install -y python3 python3-venv python3-pip git
   ```

2. Create app user and directory:

   ```bash
   sudo adduser --system --group app
   sudo mkdir -p /opt/tnm-wizard
   sudo chown -R app:app /opt/tnm-wizard
   ```

3. Copy this codebase into `/opt/tnm-wizard` (git clone or scp/rsync).

4. As user `app`:

   ```bash
   sudo -u app -s
   cd /opt/tnm-wizard
   python3 -m venv .venv
   source .venv/bin/activate
   pip install --upgrade pip
   pip install -r requirements.txt
   ```

5. Create `/etc/systemd/system/tnm-wizard.service`:

   ```ini
   [Unit]
   Description=TNM Wizard FastAPI app
   After=network-online.target
   Wants=network-online.target

   [Service]
   User=app
   Group=app
   WorkingDirectory=/opt/tnm-wizard
   Environment="PATH=/opt/tnm-wizard/.venv/bin"
   ExecStart=/opt/tnm-wizard/.venv/bin/uvicorn app:app \
     --host 0.0.0.0 --port 8000 --workers 2

   Restart=on-failure
   RestartSec=5

   [Install]
   WantedBy=multi-user.target
   ```

6. Enable + start:

   ```bash
   sudo systemctl daemon-reload
   sudo systemctl enable tnm-wizard.service
   sudo systemctl start tnm-wizard.service
   sudo systemctl status tnm-wizard.service
   ```

Then the app is available on the intranet at:

* `http://<pi-ip>:8000/`

We can later put nginx or Caddy in front if we want a nicer port or TLS, but it’s optional for an internal-only lab network.

---

If we want next steps, we can adjust just the `buildHistologicSummaryFromDOM` logic so that:

* Non-AD: description uses only subtype.
* AD: keep the current “type, subtype(%)…” format.

But from a deployment perspective, the current code is consistent and the app is ready to run on the Pi exactly as-is.
