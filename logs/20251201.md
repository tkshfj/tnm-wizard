# Progress log

TNM Wizard

We propose the design of a small intranet web application, “TNM Wizard,” which can be accessed from Windows clients via a web browser. The application converts structured input choices into standardized synoptic cancer pathology diagnostic paragraphs, in line with the Japanese General Rules for Clinical and Pathological Study of Cancer.

This report describes the recent exchanges about the TNM Wizard proof-of-concept web app, focusing on:

* The FastAPI endpoint refactor and nodal summary parser
* The Jinja form template (`form_generic.html`) design
* `visibility.js` behaviour for conditional fields
* CSS for aligned, compact nodal station inputs
* The collapsible nodal metastasis section and custom summary marker

## 1. Context: TNM Wizard PoC and Environment

We are building a small intranet-friendly TNM wizard web app that:

* Runs with **FastAPI + Uvicorn** (example run command):

  ```bash
  % uvicorn app:app --reload
  ```

* Uses **Jinja2 templates** for the form and report rendering.

* Uses **YAML config** (`lung.yaml`) to define organ-specific sections and fields.

* Implements dynamic show/hide logic in **`visibility.js`**.

* Generates a diagnostic text (e.g., lung cancer) and copies it to the clipboard in the browser.

* Recently extended to support structured input for **nodal stations** (LN1R, LN3p, etc.) with positive/total counts, and a derived compact summary string like:

  ```text
  1R (1/3), 3p (2/4)
  ```

The environment is macOS for development, but the app is targeted for use in intranet Windows machines with Firefox.

---

## 2. FastAPI Endpoint Refactor and Nodal Summary

### 2.1 Original route (simplified)

The original `/ {organ} /generate` route looked like this:

```python
@app.post("/{organ}/generate", response_class=HTMLResponse)
async def generate_report(request: Request, organ: str):
    cfg = FORM_CONFIGS.get(organ)
    if not cfg:
        return HTMLResponse("Unknown organ", status_code=404)

    form = await request.form()
    data = extract_fields(form, cfg)
    data["version"] = cfg.version
    data["nodal_summary"] = build_nodal_summary(dict(form))

    if "pT" in data and "pN" in data and "pM" in data:
        data["stage"] = derive_stage(cfg, data["pT"], data["pN"], data["pM"])

    report_text = templates.get_template(cfg.template_name).render(data=data)

    return templates.TemplateResponse(
        "result.html",
        {"request": request, "report_text": report_text, "organ": organ},
    )
```

This already included:

* `extract_fields(form, cfg)` to map form values into a structured `data` dict.
* A `version` field from `cfg.version`.
* `build_nodal_summary(dict(form))` to generate `data["nodal_summary"]`.
* `derive_stage(cfg, pT, pN, pM)` to compute stage when TNM values are present.

### 2.2 Error: treating YAML sections as objects

Refactoring led to this error:

```text
AttributeError: 'dict' object has no attribute 'fields'
  ...
  if any(f.type == "nodal_stations" for section in cfg.sections for f in section.fields):
```

Root cause:

* `cfg.sections` is a list of **dicts**, not objects with `.fields`.
* So `section.fields` must be `section["fields"]` or `section.get("fields", [])`.
* Similarly, fields are dicts, so we must use `field["type"]` / `field.get("type")`.

### 2.3 Refactored endpoint with safe detection of nodal_stations

A robust version of the endpoint:

```python
from typing import Dict, Any

@app.post("/{organ}/generate", response_class=HTMLResponse)
async def generate_report(request: Request, organ: str):
    # 1. Look up config
    cfg = FORM_CONFIGS.get(organ)
    if cfg is None:
        return HTMLResponse("Unknown organ", status_code=404)

    # 2. Raw form data once
    form = await request.form()
    form_dict: Dict[str, Any] = dict(form)

    # 3. Extract structured data
    data = extract_fields(form, cfg)

    # 4. Version (supports both object and dict configs)
    version = getattr(cfg, "version", None)
    if version is None and isinstance(cfg, dict):
        version = cfg.get("version")
    if version is not None:
        data["version"] = version

    # 5. Identify if this config uses nodal_stations
    sections = getattr(cfg, "sections", None)
    if sections is None and isinstance(cfg, dict):
        sections = cfg.get("sections", [])

    has_nodal_stations = any(
        isinstance(field, dict) and field.get("type") == "nodal_stations"
        for section in (sections or [])
        if isinstance(section, dict)
        for field in section.get("fields", [])
    )

    if has_nodal_stations:
        data["nodal_summary"] = build_nodal_summary(form_dict)
    else:
        data["nodal_summary"] = ""

    # 6. Derive stage if TNM present
    pT = data.get("pT")
    pN = data.get("pN")
    pM = data.get("pM")
    if pT and pN and pM:
        data["stage"] = derive_stage(cfg, pT, pN, pM)

    # 7. Render report
    template_name = getattr(cfg, "template_name", None)
    if isinstance(cfg, dict):
        template_name = cfg.get("template_name")

    template = templates.get_template(template_name)
    report_text = template.render(data=data)

    # 8. Return result
    return templates.TemplateResponse(
        "result.html",
        {
            "request": request,
            "report_text": report_text,
            "organ": organ,
        },
    )
```

Key points:

* Safely treats `cfg` as either an object or a dict.
* Uses `section.get("fields", [])` and `field.get("type")`.
* `data["nodal_summary"]` is set only if a `nodal_stations` field exists.

---

## 3. Nodal Summary Parser (`build_nodal_summary`)

We added a helper to parse nodal station counts from the form and produce a compact summary like:

```text
1R (1/3), 3p (2/4)
```

### 3.1 Helper function

```python
from typing import Mapping

def build_nodal_summary(form_data: Mapping[str, str]) -> str:
    """
    Parse LNxx_positive / LNxx_total pairs from the form data and build
    a compact summary like: '1R (1/3), 3p (2/4)'.

    Expected fields:
      - LN1R_positive, LN1R_total
      - LN1L_positive, LN1L_total
      - LN2R_positive, LN2R_total
      ...
    """
    summary_parts = []

    POS_SUFFIX = "_positive"
    TOTAL_SUFFIX = "_total"

    for key, pos_val in form_data.items():
        if not key.endswith(POS_SUFFIX):
            continue

        pos_val = (pos_val or "").strip()
        if pos_val == "":
            continue

        base = key[:-len(POS_SUFFIX)]  # "LN1R" from "LN1R_positive"
        total_key = f"{base}{TOTAL_SUFFIX}"
        total_val = (form_data.get(total_key) or "").strip()

        # Optional: only include if checkbox LNxx checked
        checkbox_val = (form_data.get(base) or "").strip()
        if checkbox_val.lower() not in {"true", "on", "1"}:
            # If strict filtering is desired, we can 'continue' here.
            # For now we allow inclusion if 'positive' is filled.
            pass

        # Human-readable label: strip "LN" prefix → "1R", "3p"
        label = base[2:] if base.startswith("LN") else base

        if total_val:
            summary_parts.append(f"{label} ({pos_val}/{total_val})")
        else:
            summary_parts.append(f"{label} ({pos_val}/?)")

    return ", ".join(summary_parts)
```

Assumptions:

* The nodal template names checkboxes and inputs consistently, e.g.:

  * `name="LN1R"` (checkbox)
  * `name="LN1R_positive"`
  * `name="LN1R_total"`

The report template (`lung_report.j2`) can then use:

```jinja2
{% if data.nodal_summary %}
リンパ節転移: {{ data.nodal_summary }}
{% else %}
リンパ節転移: 記載なし
{% endif %}
```

---

## 4. `form_generic.html`: General Fields + Nodal Stations

We refactored `form_generic.html` to:

1. Keep a generic `render_input(field)` macro.
2. Add a `render_section_fields(section)` macro to handle both generic fields and a special `nodal_stations` type.
3. Wrap the nodal metastasis section in a `<details>` collapsible.

### 4.1 `render_input` macro (generic fields)

```html
{% macro render_input(field) %}
  {% if field.type == "radio" %}
    {% set default_value = field.default or "" %}
    {% for opt in field.options %}
      <label
        {% if opt.help %} title="{{ opt.help }}"{% endif %}
        class="radio-option"
      >
        <input
          type="radio"
          name="{{ field.name }}"
          value="{{ opt.code }}"
          {% if opt.code == default_value or opt.default %}checked{% endif %}
          required
        >
        {{ opt.label }}
      </label>
    {% endfor %}

  {% elif field.type == "select" %}
    <select name="{{ field.name }}">
      {% for opt in field.options %}
        <option value="{{ opt.code }}">{{ opt.label }}</option>
      {% endfor %}
    </select>

  {% elif field.type == "checkbox" %}
    {% if field.options %}
      {# multi-choice checkboxes #}
      {% for opt in field.options %}
        <label class="checkbox-option"
               {% if opt.help %}title="{{ opt.help }}"{% endif %}>
          <input type="checkbox" name="{{ field.name }}" value="{{ opt.code }}">
          {{ opt.label }}
        </label>
      {% endfor %}
    {% else %}
      {# single boolean checkbox #}
      <label class="checkbox-option">
        <input type="checkbox" name="{{ field.name }}" value="true">
        {{ field.label }}
      </label>
    {% endif %}

  {% elif field.type == "number" %}
    <input
      type="number"
      min="0"
      step="{{ field.step or 1 }}"
      name="{{ field.name }}"
      {% if field.input_width %}style="width: {{ field.input_width }};"{% endif %}
    >
    <span>mm</span>

  {% elif field.type == "free_text" %}
    <input
      type="text"
      name="{{ field.name }}"
      {% if field.input_width %}style="width: {{ field.input_width }};"{% endif %}
    >

  {% elif field.type == "textarea" %}
    <textarea
      name="{{ field.name }}"
      rows="{{ field.rows or 2 }}"
      class="{{ field.css_class or '' }}"
    ></textarea>

  {% else %}
    <input type="text" name="{{ field.name }}">
  {% endif %}
{% endmacro %}
```

### 4.2 `render_section_fields` macro (handles `nodal_stations`)

```html
{% macro render_section_fields(section) %}
  {% for field in section.fields %}

    {% if field.type == "nodal_stations" %}
      <div class="field nodal-stations">
        <label>{{ field.label }}:</label>

        {% for st in field.stations %}
          {% set chk_name      = "LN" ~ st.code %}
          {% set positive_name = "LN" ~ st.code ~ "_positive" %}
          {% set total_name    = "LN" ~ st.code ~ "_total" %}

          <div class="nodal-row">
            {# Station checkbox + code #}
            <label class="station-cell">
              <input type="checkbox" name="{{ chk_name }}" value="true">
              <span class="station-code">{{ st.label }}</span>
            </label>

            {# Positive count #}
            <input
              type="number"
              name="{{ positive_name }}"
              class="nodal-input"
              min="0"
              step="1"
              style="width: 3.0rem;"
              placeholder="positive"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >

            {# Slash #}
            <span
              class="nodal-slash"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >/</span>

            {# Total count #}
            <input
              type="number"
              name="{{ total_name }}"
              class="nodal-input"
              min="0"
              step="1"
              style="width: 3.0rem;"
              placeholder="total"
              data-visible-if-field="{{ chk_name }}"
              data-visible-if-values="true"
            >
          </div>
        {% endfor %}
      </div>

    {% else %}
      <div class="field"
           data-field-name="{{ field.name }}"
           {% if field.visible_if %}
             data-visible-if-field="{{ field.visible_if['field'] }}"
             data-visible-if-values="{{ field.visible_if['values'] | join(',') }}"
           {% endif %}
      >
        {% if not (field.type == "checkbox" and not field.options) %}
          <label>{{ field.label }}:</label>
        {% endif %}
        {{ render_input(field) }}
      </div>
    {% endif %}

  {% endfor %}
{% endmacro %}
```

### 4.3 Form structure with collapsible nodal metastasis section

```html
<form method="post" action="/{{ config.organ }}/generate">
  {% for section in config.sections %}

    {% if section.id == "nodal_metastasis" %}
      <details class="section-collapsible" open>
        <summary>{{ section.title }}</summary>

        <fieldset>
          <legend class="sr-only">{{ section.title }}</legend>
          {{ render_section_fields(section) }}
        </fieldset>
      </details>
    {% else %}
      <fieldset>
        <legend>{{ section.title }}</legend>
        {{ render_section_fields(section) }}
      </fieldset>
    {% endif %}

  {% endfor %}

  <button type="submit">診断文を生成</button>
</form>
```

* `details.section-collapsible` wraps the nodal section so it can be collapsed/unfolded.
* `<summary>` is the clickable header (e.g., “リンパ節転移”).
* The `sr-only` class is used to keep `legend` screen-reader accessible but visually hidden.

---

## 5. `visibility.js`: Conditional Show/Hide

To control conditional fields (such as showing `+ / #` only when a station checkbox is checked), we use `visibility.js`:

```javascript
document.addEventListener("DOMContentLoaded", () => {
  const conditionalFields = document.querySelectorAll("[data-visible-if-field]");

  function getFieldValue(name) {
    const elements = document.querySelectorAll(`[name="${name}"]`);
    if (!elements.length) return "";

    const el = elements[0];

    if (el.tagName === "SELECT") {
      return el.value;
    }

    if (el.type === "radio") {
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      return checked ? checked.value : "";
    }

    if (el.type === "checkbox") {
      const checked = document.querySelector(`input[name="${name}"]:checked`);
      // Interpret as boolean semantics
      return checked ? "true" : "false";
    }

    return el.value || "";
  }

  function updateVisibility() {
    conditionalFields.forEach((el) => {
      const depField = el.dataset.visibleIfField;
      const allowed = (el.dataset.visibleIfValues || "")
        .split(",")
        .map(v => v.trim())
        .filter(v => v !== "");
      const current = getFieldValue(depField);

      if (allowed.includes(current)) {
        el.style.display = "";        // visible
      } else {
        el.style.display = "none";    // hidden
      }
    });
  }

  updateVisibility();

  document.addEventListener("change", (event) => {
    const name = event.target.name;
    if ([...conditionalFields].some(f => f.dataset.visibleIfField === name)) {
      updateVisibility();
    }
  });
});
```

In the nodal template:

* The station checkbox is `name="{{ chk_name }}"` with `value="true"`.
* Positive and total inputs and the slash each have:

  ```html
  data-visible-if-field="{{ chk_name }}"
  data-visible-if-values="true"
  ```

When the checkbox is checked:

* `getFieldValue(chk_name)` returns `"true"`.
* Elements with `data-visible-if-values="true"` are shown.
* When unchecked, they are hidden.

---

## 6. CSS for Alignment, Compact Inputs, and Right Alignment

We tuned the appearance of the nodal metastasis fields with CSS.

### 6.1 Base body and field styles

```css
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  margin: 1.5rem;
}

fieldset {
  margin-bottom: 1rem;
  padding: 1rem;
}

.field {
  margin-bottom: 0.5rem;
}
```

### 6.2 Nodal section and rows

```css
.nodal-stations {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  align-items: flex-end;  /* right-align block inside fieldset */
}

.nodal-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
```

### 6.3 Station label and code alignment

```css
/* Fixed-width station column (checkbox + code) */
.station-cell {
  display: inline-flex;
  align-items: center;
  gap: 0.25rem;
  width: 3.5rem;     /* enough for "10R", etc. */
}

/* Just the text "1R", "9", "10", ... */
.station-code {
  min-width: 2.0rem;
  text-align: right;   /* align 1, 9, 10, 11 vertically */
  font-feature-settings: "tnum"; /* tabular numbers when available */
}
```

### 6.4 Positive / total inputs and slash

```css
/* Hide positive/total by default; JS sets display to "" when visible */
.nodal-slash,
.nodal-input[data-visible-if-field] {
  /* default state controlled by JS: style.display = "" or "none" */
}

.nodal-input {
  width: 3ch;          /* compact numeric boxes, ~3 digits */
  text-align: right;   /* numbers right-aligned inside the box */
}

.nodal-slash {
  text-align: center;
}

button {
  padding: 0.3rem 0.8rem;
  font-size: 0.9rem;
}
```

This layout produces compact rows like:

```text
リンパ節:
                             ☐ 1R [  ] / [  ]
                             ☐ 1L [  ] / [  ]
                             ☐ 2R [  ] / [  ]
                             ...
```

with everything aligned, and arithmetic values (`1`, `4`, etc.) right-aligned within the inputs.

---

## 7. Collapsible Section and Custom Summary Marker

We used HTML `<details>` / `<summary>` for a native, accessible collapsible for the nodal metastasis section:

```html
<details class="section-collapsible" open>
  <summary>リンパ節転移</summary>
  <fieldset>
    <legend class="sr-only">リンパ節転移</legend>
    {{ render_section_fields(section) }}
  </fieldset>
</details>
```

### 7.1 Accessibility helper for hidden legend

```css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

### 7.2 Custom arrow instead of default triangle (optional)

Browsers show a built-in marker (triangle) before `<summary>`. To hide and replace it:

```css
/* Hide default marker in Chrome / Edge / Safari */
summary::-webkit-details-marker {
  display: none;
}

/* Hide default marker in Firefox */
summary::marker {
  content: "";
}

/* Style the clickable header */
.section-collapsible > summary {
  cursor: pointer;
  font-weight: bold;
  list-style: none;
  outline: none;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}

/* Custom arrow before text */
.section-collapsible > summary::before {
  content: "▶";         /* closed state */
  font-size: 0.9rem;
}

/* When <details> is open, change the icon */
.section-collapsible[open] > summary::before {
  content: "▼";         /* open state */
}
```

This gives a consistent, custom “▶ / ▼” arrow across browsers:

* Collapsed: `▶ リンパ節転移`
* Expanded: `▼ リンパ節転移`

while preserving keyboard navigation, native behaviour, and accessibility.

---

## 8. Behaviour Across Browsers (Firefox vs Chrome)

The design was kept conservative so that:

* `visibility.js` uses standard DOM APIs (`querySelectorAll`, `dataset`, event listeners).
* CSS uses widely supported features: flexbox and basic pseudo-elements.
* `<details>` / `<summary>` is supported by modern Firefox and Chrome.

There should be no significant behavioural differences between Firefox and Chrome for:

* Checkbox-controlled conditional display of `+ / #` inputs.
* Right alignment within input boxes via `text-align: right`.
* Collapsible nodal section using `<details>` / `<summary>`.

If differences appear, a hard reload and verifying in Developer Tools that:

* Inputs have the expected classes/attributes.
* CSS rules are not overridden.

will help confirm behaviour.

---

## 9. Summary

The recent work on the TNM Wizard PoC focused on:

* Refactoring the FastAPI route to:

  * Safely handle dict-based config structures.
  * Detect `nodal_stations` dynamically.
  * Compute a compact `nodal_summary` from LNxx_positive / LNxx_total pairs.
* Designing a flexible Jinja template (`form_generic.html`) that:

  * Uses macros to render generic fields and nodal-specific rows.
  * Implements nodal stations as rows of `checkbox + station label + positive / total` inputs.
  * Supports conditional visibility for `+ / #` fields based on station checkbox state.
* Implementing `visibility.js` to manage conditional display using `data-visible-if-*` attributes.
* Styling the nodal section with CSS for:

  * Right-aligned, compact numeric inputs.
  * Neat vertical alignment of station names and columns.
  * Right-aligned nodal block within the fieldset.
* Adding a collapsible nodal metastasis section using `<details>` / `<summary>` with optional custom arrows via CSS.

This structure is general enough to extend beyond lung to other organs while keeping the nodal UI and logic reusable and clean.
